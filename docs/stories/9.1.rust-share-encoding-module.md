# Story 9.1: Rust Share Encoding Module

## Status

Draft

## Story

**As a** user with JSON content I want to share,
**I want** the application to generate a time-bounded encrypted, compressed payload with optional passphrase protection,
**so that** I can create secure shareable URLs that expire after 5 minutes, with optional two-factor security.

## Acceptance Criteria

1. Rust module `share` implements `create_share_payload(json: &str, passphrase: Option<&str>) -> Result<SharePayload, ShareError>`
2. `SharePayload` struct contains `data: String` (Base64URL encoded ciphertext) and `key: Option<String>` (only present if no passphrase)
3. JSON is compressed using DEFLATE before encryption (flate2 crate)
4. Payload prepends version byte: `0x01` = random key mode, `0x02` = passphrase mode
5. Payload prepends current Unix timestamp (8 bytes, big-endian) after version byte
6. **Random key mode (no passphrase):** Generate random 256-bit AES key, include in response
7. **Passphrase mode:** Derive key via PBKDF2-SHA256 with 100,000 iterations and random 16-byte salt (salt prepended to ciphertext)
8. Encryption uses AES-256-GCM with random 12-byte nonce (prepended to ciphertext)
9. All binary data is Base64URL encoded (URL-safe, no padding)
10. Function returns `ShareError::PayloadTooLarge` if encoded data exceeds 6000 characters
11. WASM binding exposed: `createSharePayload(json: string, passphrase: string) -> string` (empty passphrase = random key mode)
12. Unit tests verify: both modes round-trip, passphrase derivation consistency, error handling
13. WASM size increase is under 150KB gzipped (PBKDF2 adds some size)

## Tasks / Subtasks

- [ ] Task 1: Add Rust dependencies to Cargo.toml (AC: 3, 6, 7, 9)
  - [ ] Add `flate2 = "1.0"` for DEFLATE compression
  - [ ] Add `aes-gcm = "0.10"` for AES-256-GCM encryption
  - [ ] Add `base64 = "0.21"` for Base64URL encoding
  - [ ] Add `pbkdf2 = "0.12"` for passphrase key derivation
  - [ ] Add `sha2 = "0.10"` for PBKDF2-SHA256
  - [ ] Add `getrandom = { version = "0.2", features = ["js"] }` for WASM-compatible randomness
  - [ ] Verify WASM build succeeds with new dependencies

- [ ] Task 2: Create share module structure (AC: 1, 2, 4)
  - [ ] Create `src/share.rs` with module definition
  - [ ] Define `SharePayload` struct with `data: String` and `key: Option<String>`
  - [ ] Define `ShareError` enum with variants: `CompressionFailed`, `EncryptionFailed`, `PayloadTooLarge`, `EmptyInput`, `KeyDerivationFailed`
  - [ ] Define version constants: `VERSION_RANDOM_KEY: u8 = 0x01`, `VERSION_PASSPHRASE: u8 = 0x02`
  - [ ] Add `mod share;` to `src/lib.rs`

- [ ] Task 3: Implement compression with version and timestamp (AC: 3, 4, 5)
  - [ ] Implement `compress_with_header(json: &str, version: u8) -> Result<Vec<u8>, ShareError>`
  - [ ] Get current Unix timestamp using `js_sys::Date::now()` (WASM-compatible)
  - [ ] Prepend version byte (1 byte) + timestamp (8 bytes big-endian) to JSON bytes
  - [ ] Compress combined payload using DEFLATE (default compression level)
  - [ ] Unit test: verify version and timestamp are correctly embedded

- [ ] Task 4: Implement PBKDF2 key derivation for passphrase mode (AC: 7)
  - [ ] Implement `derive_key_from_passphrase(passphrase: &str, salt: &[u8]) -> Result<[u8; 32], ShareError>`
  - [ ] Use PBKDF2-SHA256 with 100,000 iterations
  - [ ] Generate random 16-byte salt
  - [ ] Return 256-bit derived key
  - [ ] Unit test: same passphrase + salt produces same key

- [ ] Task 5: Implement AES-256-GCM encryption (AC: 6, 8)
  - [ ] Implement `encrypt_payload(data: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, ShareError>`
  - [ ] Generate random 12-byte nonce
  - [ ] Encrypt data with AES-256-GCM
  - [ ] Prepend nonce to ciphertext (12 bytes + ciphertext)
  - [ ] Unit test: verify encryption produces different output each time (random nonce)

- [ ] Task 6: Implement random key generation (AC: 6)
  - [ ] Implement `generate_random_key() -> Result<[u8; 32], ShareError>`
  - [ ] Use `getrandom` for cryptographically secure randomness
  - [ ] Unit test: verify keys are unique

- [ ] Task 7: Implement Base64URL encoding and payload assembly (AC: 9, 10)
  - [ ] Implement `encode_base64url(data: &[u8]) -> String` using base64::URL_SAFE_NO_PAD
  - [ ] Implement `create_share_payload(json: &str, passphrase: Option<&str>) -> Result<SharePayload, ShareError>`
  - [ ] **Random key mode:** compress → encrypt with random key → encode → return data + key
  - [ ] **Passphrase mode:** compress → generate salt → derive key → prepend salt to ciphertext → encrypt → encode → return data only
  - [ ] Check encoded data length, return `PayloadTooLarge` if > 6000 chars
  - [ ] Unit test: verify Base64URL output contains no `+`, `/`, or `=` characters

- [ ] Task 8: Add WASM bindings (AC: 11)
  - [ ] Add `#[wasm_bindgen]` export for `createSharePayload(json: String, passphrase: String)`
  - [ ] Empty passphrase string = random key mode
  - [ ] Return JSON string:
    - Random key: `{"success": true, "data": "...", "key": "...", "mode": "quick"}`
    - Passphrase: `{"success": true, "data": "...", "mode": "protected"}`
    - Error: `{"success": false, "error": "..."}`
  - [ ] Integration test: call from JavaScript, verify JSON response structure for both modes

- [ ] Task 9: Testing and validation (AC: 12, 13)
  - [ ] Write unit tests for round-trip both modes
  - [ ] Test passphrase key derivation consistency
  - [ ] Test compression ratio: typical JSON should compress 50%+
  - [ ] Test error handling: empty input, very large input
  - [ ] Verify WASM build size increase (check dist/pkg/*.wasm size)
  - [ ] Manual test in browser DevTools

## Dev Notes

### Relevant Source Tree
```
src/
├── lib.rs              # WASM entry point - add share module export here
├── formatter.rs        # Existing - pattern for error handling
├── validator.rs        # Existing - pattern for Result types
└── share.rs            # NEW - share encoding/decoding module
Cargo.toml              # Add new dependencies here
```

### Existing Patterns to Follow
- Error handling pattern from `formatter.rs`: use custom error enum with `impl std::fmt::Display`
- WASM binding pattern from `lib.rs`: return JSON strings for complex types
- Use `#[wasm_bindgen]` with `js_name` attribute for camelCase JS function names

### Cargo.toml Additions
```toml
[dependencies]
# Existing deps...
flate2 = "1.0"
aes-gcm = "0.10"
base64 = "0.21"
pbkdf2 = "0.12"
sha2 = "0.10"
getrandom = { version = "0.2", features = ["js"] }
```

### Key Implementation Details

**Version and timestamp handling:**
```rust
use js_sys::Date;

const VERSION_RANDOM_KEY: u8 = 0x01;
const VERSION_PASSPHRASE: u8 = 0x02;
const PBKDF2_ITERATIONS: u32 = 100_000;
const SALT_LENGTH: usize = 16;

fn get_unix_timestamp() -> u64 {
    (Date::now() / 1000.0) as u64  // Convert ms to seconds
}
```

**PBKDF2 key derivation (passphrase mode):**
```rust
use pbkdf2::pbkdf2_hmac;
use sha2::Sha256;

fn derive_key_from_passphrase(passphrase: &str, salt: &[u8]) -> Result<[u8; 32], ShareError> {
    let mut key = [0u8; 32];
    pbkdf2_hmac::<Sha256>(
        passphrase.as_bytes(),
        salt,
        PBKDF2_ITERATIONS,
        &mut key
    );
    Ok(key)
}
```

**AES-GCM encryption pattern:**
```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, KeyInit};

fn encrypt_payload(data: &[u8], key_bytes: &[u8; 32]) -> Result<Vec<u8>, ShareError> {
    let key = Key::<Aes256Gcm>::from_slice(key_bytes);
    let cipher = Aes256Gcm::new(key);

    let mut nonce_bytes = [0u8; 12];
    getrandom::getrandom(&mut nonce_bytes).map_err(|_| ShareError::EncryptionFailed)?;
    let nonce = Nonce::from_slice(&nonce_bytes);

    let ciphertext = cipher.encrypt(nonce, data)
        .map_err(|_| ShareError::EncryptionFailed)?;

    // Prepend nonce to ciphertext
    let mut result = nonce_bytes.to_vec();
    result.extend(ciphertext);

    Ok(result)
}
```

**Payload structure (passphrase mode):**
```
[salt: 16 bytes][nonce: 12 bytes][ciphertext...]
Where ciphertext contains: [version: 1 byte][timestamp: 8 bytes][compressed_json...]
```

**Payload structure (random key mode):**
```
[nonce: 12 bytes][ciphertext...]
Where ciphertext contains: [version: 1 byte][timestamp: 8 bytes][compressed_json...]
```

**Base64URL encoding:**
```rust
use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};

fn encode_base64url(data: &[u8]) -> String {
    URL_SAFE_NO_PAD.encode(data)
}
```

### Testing

**Test file location:** `src/share.rs` (inline tests) or `src/tests/share_tests.rs`

**Testing frameworks:**
- `#[cfg(test)]` module for unit tests
- `wasm-bindgen-test` for WASM integration tests

**Key test cases:**
1. Empty input returns `ShareError::EmptyInput`
2. Round-trip: `create_share_payload` → `decode_share_payload` recovers original JSON
3. Large input (>50KB) returns `ShareError::PayloadTooLarge` or succeeds if under 6000 chars encoded
4. Output contains only URL-safe characters
5. Different calls produce different ciphertext (random nonce/key)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*
