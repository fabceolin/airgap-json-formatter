# Story 9.2: Rust Share Decoding & Validation

## Status

Draft

## Story

**As a** user who received a shared URL,
**I want** the application to decrypt and validate the shared payload (with or without passphrase),
**so that** I can view the shared JSON content if the link hasn't expired and I have the correct credentials.

## Acceptance Criteria

1. Rust module `share` implements `decode_share_payload(data: &str, key_or_passphrase: &str, is_passphrase: bool) -> Result<DecodeResult, ShareError>`
2. `DecodeResult` struct contains `json: String`, `created_at: u64`, and `mode: String` ("quick" or "protected")
3. Function Base64URL decodes data input
4. **Random key mode (is_passphrase=false):** Extract 12-byte nonce, decrypt with provided key
5. **Passphrase mode (is_passphrase=true):** Extract 16-byte salt, derive key via PBKDF2, extract nonce, decrypt
6. Function reads version byte from decrypted payload to verify mode matches
7. Function extracts and validates timestamp (bytes 1-8 of decrypted data, after version byte)
8. Function returns `ShareError::Expired` if timestamp is older than 5 minutes (300 seconds)
9. Function decompresses remaining bytes using DEFLATE to recover original JSON
10. Function returns `ShareError::InvalidPayload` for malformed data (wrong length, bad encoding, version mismatch)
11. Function returns `ShareError::DecryptionFailed` for wrong key/passphrase or tampered data
12. WASM binding exposed: `decodeSharePayload(data: string, keyOrPassphrase: string, isPassphrase: boolean) -> string`
13. WASM response includes: `{success, json?, createdAt?, mode?, error?, errorCode?}`
14. Error codes: `expired`, `invalid_payload`, `decryption_failed`, `invalid_base64`, `wrong_passphrase`
15. Unit tests verify: both modes, expired rejection, wrong passphrase rejection, tampered data rejection

## Tasks / Subtasks

- [ ] Task 1: Define DecodeResult and extend ShareError (AC: 2, 8, 10, 11, 14)
  - [ ] Add `DecodeResult` struct with `json: String`, `created_at: u64`, and `mode: String`
  - [ ] Add error variants to `ShareError`: `Expired`, `InvalidPayload`, `DecryptionFailed`, `InvalidBase64`, `WrongPassphrase`
  - [ ] Implement `Display` for new error variants with user-friendly messages

- [ ] Task 2: Implement Base64URL decoding (AC: 3)
  - [ ] Implement `decode_base64url(input: &str) -> Result<Vec<u8>, ShareError>`
  - [ ] Return `ShareError::InvalidBase64` for invalid input
  - [ ] Unit test: verify round-trip with encoder from Story 9.1

- [ ] Task 3: Implement PBKDF2 key derivation for passphrase mode (AC: 5)
  - [ ] Reuse `derive_key_from_passphrase(passphrase: &str, salt: &[u8])` from Story 9.1
  - [ ] Extract 16-byte salt from beginning of passphrase-mode payload
  - [ ] Unit test: verify same passphrase + salt produces same key as encoding

- [ ] Task 4: Implement AES-256-GCM decryption (AC: 4, 5, 11)
  - [ ] Implement `decrypt_payload(ciphertext: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, ShareError>`
  - [ ] Extract first 12 bytes as nonce
  - [ ] Decrypt remaining bytes with AES-256-GCM
  - [ ] Return `ShareError::DecryptionFailed` on authentication failure
  - [ ] Return `ShareError::InvalidPayload` if ciphertext too short
  - [ ] Unit test: verify decryption fails gracefully with wrong key

- [ ] Task 5: Implement version byte and timestamp extraction (AC: 6, 7, 8)
  - [ ] Implement `extract_header(data: &[u8]) -> Result<(u8, u64, &[u8]), ShareError>`
  - [ ] Extract version byte (first byte)
  - [ ] Extract timestamp (bytes 1-8, big-endian u64)
  - [ ] Get current timestamp using `js_sys::Date::now()`
  - [ ] Return `ShareError::Expired` if (current - timestamp) > 300 seconds
  - [ ] Return remaining bytes (compressed JSON) for decompression
  - [ ] Unit test: verify expiration boundary (299s OK, 301s expired)

- [ ] Task 6: Implement DEFLATE decompression (AC: 9)
  - [ ] Implement `decompress_json(compressed: &[u8]) -> Result<String, ShareError>`
  - [ ] Use flate2 DeflateDecoder
  - [ ] Return `ShareError::CompressionFailed` on decompression error
  - [ ] Validate decompressed output is valid UTF-8
  - [ ] Unit test: verify decompression of data compressed in Story 9.1

- [ ] Task 7: Assemble decode_share_payload function (AC: 1, 6, 10)
  - [ ] Implement `decode_share_payload(data: &str, key_or_passphrase: &str, is_passphrase: bool)`
  - [ ] **Random key mode:**
    - decode_base64url(data) → decrypt_payload(key) → extract_header → decompress
    - Verify version byte is 0x01
  - [ ] **Passphrase mode:**
    - decode_base64url(data) → extract salt → derive_key → decrypt_payload → extract_header → decompress
    - Verify version byte is 0x02
  - [ ] Return `ShareError::InvalidPayload` if version doesn't match mode
  - [ ] Return `DecodeResult` with JSON, timestamp, and mode

- [ ] Task 8: Add WASM bindings (AC: 12, 13)
  - [ ] Add `#[wasm_bindgen]` export for `decodeSharePayload(data, keyOrPassphrase, isPassphrase)`
  - [ ] Return JSON with structure:
    ```json
    {
      "success": true,
      "json": "...",
      "createdAt": 1706367600,
      "mode": "quick"
    }
    ```
    or
    ```json
    {
      "success": false,
      "error": "Link has expired",
      "errorCode": "expired"
    }
    ```
  - [ ] Map error codes: `expired`, `invalid_payload`, `decryption_failed`, `invalid_base64`, `wrong_passphrase`

- [ ] Task 9: Integration testing (AC: 15)
  - [ ] Test successful round-trip: random key mode
  - [ ] Test successful round-trip: passphrase mode
  - [ ] Test expired link (mock timestamp 6 minutes ago)
  - [ ] Test tampered data (flip bit in ciphertext)
  - [ ] Test wrong key (random key mode)
  - [ ] Test wrong passphrase (passphrase mode)
  - [ ] Test mode mismatch (try to decode passphrase link with key)
  - [ ] Test truncated data (missing bytes)
  - [ ] Test invalid Base64 input

## Dev Notes

### Relevant Source Tree
```
src/
├── lib.rs              # WASM exports - add decodeSharePayload
├── share.rs            # Encoding (Story 9.1) + Decoding (this story)
```

### Dependencies (already added in Story 9.1)
- `flate2` for decompression
- `aes-gcm` for decryption
- `base64` for Base64URL decoding
- `js_sys` for current timestamp

### Key Implementation Details

**Base64URL decoding:**
```rust
use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};

fn decode_base64url(input: &str) -> Result<Vec<u8>, ShareError> {
    URL_SAFE_NO_PAD.decode(input)
        .map_err(|_| ShareError::InvalidBase64)
}
```

**AES-GCM decryption pattern:**
```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, KeyInit};

fn decrypt_payload(ciphertext: &[u8], key_bytes: &[u8]) -> Result<Vec<u8>, ShareError> {
    if ciphertext.len() < 12 {
        return Err(ShareError::InvalidPayload);
    }
    if key_bytes.len() != 32 {
        return Err(ShareError::InvalidPayload);
    }

    let (nonce_bytes, encrypted) = ciphertext.split_at(12);
    let nonce = Nonce::from_slice(nonce_bytes);
    let key = Key::<Aes256Gcm>::from_slice(key_bytes);
    let cipher = Aes256Gcm::new(key);

    cipher.decrypt(nonce, encrypted)
        .map_err(|_| ShareError::DecryptionFailed)
}
```

**Timestamp validation:**
```rust
use js_sys::Date;

const EXPIRATION_SECS: u64 = 300; // 5 minutes

fn validate_timestamp(created_at: u64) -> Result<(), ShareError> {
    let now = (Date::now() / 1000.0) as u64;
    if now.saturating_sub(created_at) > EXPIRATION_SECS {
        return Err(ShareError::Expired);
    }
    Ok(())
}
```

**DEFLATE decompression:**
```rust
use flate2::read::DeflateDecoder;
use std::io::Read;

fn decompress_json(compressed: &[u8]) -> Result<String, ShareError> {
    let mut decoder = DeflateDecoder::new(compressed);
    let mut decompressed = Vec::new();
    decoder.read_to_end(&mut decompressed)
        .map_err(|_| ShareError::CompressionFailed)?;

    String::from_utf8(decompressed)
        .map_err(|_| ShareError::InvalidPayload)
}
```

### Error Code Mapping for WASM Response

| ShareError variant | errorCode | User-friendly message |
|-------------------|-----------|----------------------|
| `Expired` | `"expired"` | "This shared link has expired (links are valid for 5 minutes)" |
| `InvalidPayload` | `"invalid_payload"` | "Invalid share link format" |
| `DecryptionFailed` | `"decryption_failed"` | "Unable to decrypt - the link may be corrupted" |
| `InvalidBase64` | `"invalid_base64"` | "Invalid share link encoding" |

### Testing

**Test file location:** `src/share.rs` (inline tests)

**Critical test: Expiration boundary**
```rust
#[test]
fn test_expiration_boundary() {
    // Create payload, then manually adjust timestamp
    // 299 seconds ago: should succeed
    // 300 seconds ago: should succeed (inclusive)
    // 301 seconds ago: should fail with Expired
}
```

**Critical test: Tamper detection**
```rust
#[test]
fn test_tamper_detection() {
    let payload = create_share_payload(r#"{"test": "data"}"#).unwrap();
    let mut tampered = decode_base64url(&payload.data).unwrap();
    tampered[20] ^= 0xFF;  // Flip some bits
    let tampered_data = encode_base64url(&tampered);

    let result = decode_share_payload(&tampered_data, &payload.key);
    assert!(matches!(result, Err(ShareError::DecryptionFailed)));
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*
