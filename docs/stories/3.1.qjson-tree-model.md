# Story 3.1: QJsonTreeModel - C++ Data Model

## Status: Draft

## Story

**As a** developer integrating the TreeView feature,
**I want** a C++ tree model that converts JSON into Qt's hierarchical model format,
**so that** the QML TreeView can display JSON structure with expand/collapse capability.

## Story Context

**Existing System Integration:**
- Integrates with: JsonBridge (C++), Qt 6 QML TreeView
- Technology: Qt 6 C++, QAbstractItemModel, serde_json (Rust)
- Follows pattern: C++ model exposed to QML via Q_PROPERTY/Q_INVOKABLE
- Touch points: jsonbridge.cpp, jsonbridge.h, CMakeLists.txt, new QJsonTreeModel files

## Acceptance Criteria

**Functional Requirements:**

1. `QJsonTreeModel` class extends `QAbstractItemModel`
2. Model correctly represents nested JSON objects as parent-child nodes
3. Model correctly represents JSON arrays with indexed children `[0]`, `[1]`, etc.
4. Model provides roles: `key`, `value`, `valueType`, `jsonPath`, `childCount`, `isExpandable`
5. Model handles all JSON types: object, array, string, number, boolean, null
6. Model handles edge cases: empty objects `{}`, empty arrays `[]`, root primitives

**Integration Requirements:**

7. Model is registered as QML type and accessible from QML
8. `JsonBridge` exposes method to create/populate the model from JSON string
9. Model updates correctly when new JSON is loaded
10. Existing JsonBridge methods remain unchanged

**Quality Requirements:**

11. Model handles JSON up to 1MB without blocking UI (< 100ms parse time)
12. Memory usage is reasonable for large JSON files
13. No memory leaks when loading new JSON (proper cleanup)

## Tasks / Subtasks

- [ ] Task 1: Create QJsonTreeItem class (AC: 2, 3, 5, 6)
  - [ ] Create `qjsontreeitem.h` and `qjsontreeitem.cpp`
  - [ ] Implement tree node with: key, value, type, parent pointer, children list
  - [ ] Support all JSON value types (object, array, string, number, bool, null)
  - [ ] Implement `jsonPath()` method returning path like `$.address.city`

- [ ] Task 2: Create QJsonTreeModel class (AC: 1, 4, 7)
  - [ ] Create `qjsontreemodel.h` and `qjsontreemodel.cpp`
  - [ ] Extend `QAbstractItemModel`
  - [ ] Implement required virtual methods: `index()`, `parent()`, `rowCount()`, `columnCount()`, `data()`
  - [ ] Define role names enum and `roleNames()` override
  - [ ] Register as QML type: `qmlRegisterType<QJsonTreeModel>`

- [ ] Task 3: Implement JSON parsing to tree (AC: 2, 3, 5, 6)
  - [ ] Implement `loadJson(const QString& jsonString)` method
  - [ ] Recursively parse JSON objects into tree structure
  - [ ] Recursively parse JSON arrays with indexed keys
  - [ ] Handle root-level primitives (string, number, etc.)
  - [ ] Emit `modelReset()` signal after loading

- [ ] Task 4: Integrate with JsonBridge (AC: 8, 9, 10)
  - [ ] Add `Q_PROPERTY` for `QJsonTreeModel* treeModel`
  - [ ] Add `Q_INVOKABLE` method `loadTreeModel(const QString& json)`
  - [ ] Ensure existing methods unchanged

- [ ] Task 5: Update CMakeLists.txt (AC: 7)
  - [ ] Add new source files to build
  - [ ] Ensure proper Qt6 linking

- [ ] Task 6: Testing (AC: 11, 12, 13)
  - [ ] Test with small JSON (< 1KB)
  - [ ] Test with medium JSON (~100KB)
  - [ ] Test with large JSON (~1MB)
  - [ ] Test edge cases: empty object, empty array, deeply nested (>10 levels)
  - [ ] Verify memory cleanup when reloading

## Dev Notes

### Relevant Source Tree
```
qt/
├── CMakeLists.txt           # Build config (modify)
├── jsonbridge.h             # Bridge header (modify)
├── jsonbridge.cpp           # Bridge implementation (modify)
├── qjsontreeitem.h          # NEW: Tree node class
├── qjsontreeitem.cpp        # NEW: Tree node implementation
├── qjsontreemodel.h         # NEW: Tree model class
├── qjsontreemodel.cpp       # NEW: Tree model implementation
└── qml/
    └── Main.qml             # Will use model in Story 3.2
```

### QJsonTreeItem Class Design

```cpp
// qjsontreeitem.h
#ifndef QJSONTREEITEM_H
#define QJSONTREEITEM_H

#include <QString>
#include <QVariant>
#include <QVector>

class QJsonTreeItem
{
public:
    enum class Type { Object, Array, String, Number, Boolean, Null };

    explicit QJsonTreeItem(QJsonTreeItem* parent = nullptr);
    ~QJsonTreeItem();

    void appendChild(QJsonTreeItem* child);
    QJsonTreeItem* child(int row);
    int childCount() const;
    int row() const;
    QJsonTreeItem* parentItem();

    // Data
    QString key() const;
    void setKey(const QString& key);

    QVariant value() const;
    void setValue(const QVariant& value);

    Type type() const;
    void setType(Type type);

    QString typeName() const;  // "object", "array", "string", etc.
    QString jsonPath() const;
    bool isExpandable() const; // true for object/array with children

private:
    QVector<QJsonTreeItem*> m_children;
    QJsonTreeItem* m_parent;
    QString m_key;
    QVariant m_value;
    Type m_type;
};

#endif // QJSONTREEITEM_H
```

### QJsonTreeModel Class Design

```cpp
// qjsontreemodel.h
#ifndef QJSONTREEMODEL_H
#define QJSONTREEMODEL_H

#include <QAbstractItemModel>
#include <QJsonDocument>
#include "qjsontreeitem.h"

class QJsonTreeModel : public QAbstractItemModel
{
    Q_OBJECT

public:
    enum Roles {
        KeyRole = Qt::UserRole + 1,
        ValueRole,
        ValueTypeRole,
        JsonPathRole,
        ChildCountRole,
        IsExpandableRole
    };

    explicit QJsonTreeModel(QObject* parent = nullptr);
    ~QJsonTreeModel() override;

    // QAbstractItemModel interface
    QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const override;
    QModelIndex parent(const QModelIndex& index) const override;
    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    int columnCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    QHash<int, QByteArray> roleNames() const override;

    // JSON loading
    Q_INVOKABLE bool loadJson(const QString& jsonString);
    Q_INVOKABLE void clear();

signals:
    void loadError(const QString& error);

private:
    void parseValue(const QJsonValue& value, QJsonTreeItem* parent, const QString& key = QString());
    void parseObject(const QJsonObject& obj, QJsonTreeItem* parent);
    void parseArray(const QJsonArray& arr, QJsonTreeItem* parent);

    QJsonTreeItem* m_rootItem;
};

#endif // QJSONTREEMODEL_H
```

### JsonBridge Integration

```cpp
// jsonbridge.h additions
class JsonBridge : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QJsonTreeModel* treeModel READ treeModel CONSTANT)
    // ... existing properties ...

public:
    // ... existing methods ...
    QJsonTreeModel* treeModel() const { return m_treeModel; }
    Q_INVOKABLE bool loadTreeModel(const QString& json);

private:
    QJsonTreeModel* m_treeModel;
};
```

### Role Names for QML Access

```cpp
QHash<int, QByteArray> QJsonTreeModel::roleNames() const
{
    return {
        {KeyRole, "key"},
        {ValueRole, "value"},
        {ValueTypeRole, "valueType"},
        {JsonPathRole, "jsonPath"},
        {ChildCountRole, "childCount"},
        {IsExpandableRole, "isExpandable"}
    };
}
```

### JSON Path Implementation

```cpp
QString QJsonTreeItem::jsonPath() const
{
    if (!m_parent) return "$";

    QString parentPath = m_parent->jsonPath();

    if (m_parent->type() == Type::Array) {
        return parentPath + "[" + m_key + "]";
    } else {
        return parentPath + "." + m_key;
    }
}
```

### Testing Considerations

**Test JSON samples:**
```json
// Empty containers
{}
[]

// Simple object
{"name": "test", "count": 42}

// Nested structure
{
  "user": {
    "name": "John",
    "address": {
      "city": "Boston"
    }
  },
  "orders": [
    {"id": 1},
    {"id": 2}
  ]
}

// Root primitive (edge case)
"just a string"
42
true
null
```

### CMakeLists.txt Addition

```cmake
set(PROJECT_SOURCES
    main.cpp
    jsonbridge.cpp
    jsonbridge.h
    qjsontreeitem.cpp      # NEW
    qjsontreeitem.h        # NEW
    qjsontreemodel.cpp     # NEW
    qjsontreemodel.h       # NEW
    # ... existing files ...
)
```

## Technical Notes

- **Integration Approach:** Pure C++ model exposed to QML via Qt's model/view architecture
- **Existing Pattern Reference:** Similar to how Qt's QFileSystemModel works
- **Key Constraints:** Must handle large JSON without UI freeze; proper memory management

## Definition of Done

- [ ] QJsonTreeModel compiles and links correctly
- [ ] Model handles all JSON types correctly
- [ ] Edge cases handled (empty containers, root primitives)
- [ ] Accessible from QML via JsonBridge.treeModel
- [ ] Performance acceptable for 1MB JSON
- [ ] No memory leaks
- [ ] Existing JsonBridge functionality unchanged

## Risk and Compatibility Check

**Minimal Risk Assessment:**
- **Primary Risk:** Memory management with tree structure
- **Mitigation:** Use smart pointers or careful parent-child ownership
- **Rollback:** Remove new files, revert JsonBridge changes

**Compatibility Verification:**
- [ ] No breaking changes to existing JsonBridge API
- [ ] Qt 6 WASM build still works
- [ ] Existing format/validate/highlight methods unchanged

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-20 | 1.0 | Initial story creation | Sarah (PO) |
