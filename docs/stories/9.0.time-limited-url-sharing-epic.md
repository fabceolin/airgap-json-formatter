# Epic 9.0: Time-Bounded Encrypted URL Sharing - Brownfield Enhancement

## Epic Goal

Enable users to share JSON content via a time-bounded encrypted URL that expires after 5 minutes, using client-side symmetric encryption and compression to securely embed the data in the URL while maintaining the airgap architecture's zero-server requirement. Optionally, users can add a passphrase for two-factor security.

## Epic Description

### Existing System Context

- **Current relevant functionality**: The application formats, validates, and displays JSON entirely client-side. Users can copy output to clipboard but have no direct sharing mechanism.
- **Technology stack**: Rust WASM (JSON processing), Qt 6 WASM (UI), JavaScript bridge layer, GitHub Pages static hosting
- **Integration points**:
  - Toolbar.qml (new Share button)
  - bridge.js (new share/decode functions)
  - Main.qml (URL parameter handling on load)
  - Rust WASM module (optional: compression/crypto if needed for performance)

### Enhancement Details

- **What's being added**: A "Share" button that generates a time-limited URL containing:
  1. Compressed JSON payload
  2. Symmetric encryption key (in URL fragment for privacy)
  3. Timestamp for 5-minute expiration validation

- **How it integrates**:
  - Share button added to Toolbar's right zone alongside Copy
  - On click: compress JSON → encrypt with generated key → encode as URL → copy to clipboard
  - On page load: detect URL parameters → decode → decrypt → validate timestamp → load if valid
  - Expired links show clear error message with option to request new share

- **Success criteria**:
  1. User can generate shareable URL with one click
  2. URL opens in any modern browser and loads the shared JSON
  3. URLs expire after 5 minutes (client-side enforced)
  4. Data remains encrypted in URL (key in fragment, not logged by servers)
  5. Compressed URLs work for JSON up to ~50KB (URL length limits)
  6. Zero network requests beyond initial page load (maintains airgap)

### Security Model

```
URL Structure (without passphrase):
https://user.github.io/airgap-json-formatter/?d=<encrypted-data>#<key>

URL Structure (with passphrase):
https://user.github.io/airgap-json-formatter/?d=<encrypted-data>&p=1

Where:
- d= : Base64URL-encoded encrypted payload containing:
  - Compressed JSON
  - Creation timestamp (Unix epoch)
  - Version byte (0x01 = no passphrase, 0x02 = passphrase-protected)
- #<key> : Base64URL-encoded symmetric key (only if no passphrase)
- p=1 : Flag indicating passphrase-protected link (key derived from passphrase)

Encryption: AES-256-GCM (Rust: aes-gcm crate)
Key Derivation: PBKDF2-SHA256 with 100,000 iterations (when passphrase used)
Compression: DEFLATE (Rust: flate2 crate)
Expiration: 5 minutes from creation timestamp
```

### Two Security Modes

1. **Quick Share (default):** Random key in URL fragment - convenient, anyone with URL can access
2. **Passphrase-Protected:** User sets passphrase, key derived via PBKDF2 - recipient must know passphrase

**Security Warning (tooltip):** "Creates a time-limited link. Anyone with this link can view the JSON for 5 minutes."

### Implementation Strategy: Rust-First

All encoding/decoding, compression, and cryptographic operations will be implemented in **Rust WASM** for:
- Consistent security implementation
- Better performance for large payloads
- Type safety and memory safety guarantees
- Alignment with existing Rust JSON processing module

JavaScript bridge will only handle:
- URL construction/parsing (browser APIs)
- Clipboard operations
- Qt WASM communication

## Stories

### Story 9.1: Rust Share Encoding Module
Implement Rust WASM module for share URL encoding with optional passphrase:
- Add Rust dependencies: `flate2` (compression), `aes-gcm` (encryption), `base64` (encoding), `pbkdf2` (key derivation)
- Implement `create_share_payload(json: &str, passphrase: Option<&str>) -> Result<SharePayload, ShareError>`
  - Compress JSON with DEFLATE
  - If no passphrase: generate random 256-bit AES key, include in response
  - If passphrase: derive key via PBKDF2-SHA256 (100k iterations), key NOT in response
  - Prepend version byte (0x01 = random key, 0x02 = passphrase-derived)
  - Encrypt payload + timestamp with AES-256-GCM
  - Return Base64URL-encoded data + optional key
- Expose via wasm-bindgen: `createSharePayload(json: string, passphrase?: string)`
- Unit tests for both modes

**Key files**: `src/share.rs` (new), `src/lib.rs` (exports), `Cargo.toml` (dependencies)

### Story 9.2: Rust Share Decoding & Validation
Implement Rust WASM module for share URL decoding with passphrase support:
- Implement `decode_share_payload(data: &str, key_or_passphrase: &str, is_passphrase: bool)`
  - Base64URL decode data
  - Read version byte to determine mode
  - If random key mode: use provided key directly
  - If passphrase mode: derive key via PBKDF2-SHA256 (same params as encoding)
  - Decrypt with AES-256-GCM
  - Validate timestamp (reject if > 5 minutes old)
  - Decompress JSON
- Expose via wasm-bindgen with appropriate response structure
- Unit tests for both modes + expiration edge cases

**Key files**: `src/share.rs`, `src/lib.rs`, `public/bridge.js` (thin wrapper)

### Story 9.3: Share Button UI Integration
Add Share button to toolbar with optional passphrase dialog:
- Share button in Toolbar.qml with security tooltip: "Creates time-bounded encrypted link (5 min). Anyone with link can view unless passphrase-protected."
- On click: show small dialog with optional passphrase field + Share/Cancel buttons
- If passphrase empty: create quick share (key in URL)
- If passphrase provided: create protected share (no key in URL, p=1 flag)
- On startup: detect share params, prompt for passphrase if p=1, decode and load
- Visual feedback: success toast, expired link error, wrong passphrase error

**Key files**: `public/bridge.js`, `qt/qml/Toolbar.qml`, `qt/qml/Main.qml`, `qt/qml/ShareDialog.qml` (new), `qt/qml/PassphrasePrompt.qml` (new)

## Compatibility Requirements

- [x] Existing APIs remain unchanged (no changes to format/validate/minify)
- [x] No database changes (stateless application)
- [x] UI changes follow existing Toolbar patterns
- [x] Performance impact is minimal (crypto operations are fast for typical JSON sizes)
- [x] Works offline after initial load (all crypto is client-side via Web Crypto API)

## Risk Mitigation

- **Primary Risk**: URL length limits (~2000 chars safe, ~8000 max) may reject large JSON
  - **Mitigation**: Compression + warn user if JSON too large; suggest manual copy for large payloads

- **Secondary Risk**: Browser compatibility for Web Crypto API
  - **Mitigation**: Web Crypto API supported in all target browsers (Chrome 90+, Firefox 88+, Safari 14+, Edge 90+)

- **Rollback Plan**: Feature is additive; can be disabled by removing Share button. No existing functionality modified.

## Definition of Done

- [ ] All 3 stories completed with acceptance criteria met
- [ ] Existing format/minify/validate/copy functionality unaffected
- [ ] Quick share (no passphrase) → Open flow works across all browsers
- [ ] Protected share (with passphrase) → Passphrase prompt → Open flow works
- [ ] Expired links show clear user-friendly error with 5-minute context
- [ ] Wrong passphrase shows clear error with retry option
- [ ] Large JSON (>50KB) shows appropriate warning in share dialog
- [ ] No console errors during share/open operations
- [ ] URL fragment key not visible in browser history or server logs (quick share mode)
- [ ] Tooltip on Share button explains time-bounded encryption and security considerations

## Technical Notes

### Rust Dependencies (Cargo.toml additions)
```toml
[dependencies]
flate2 = "1.0"           # DEFLATE compression
aes-gcm = "0.10"         # AES-256-GCM encryption
base64 = "0.21"          # Base64URL encoding
pbkdf2 = "0.12"          # PBKDF2 key derivation (passphrase mode)
sha2 = "0.10"            # SHA-256 for PBKDF2
getrandom = { version = "0.2", features = ["js"] }  # WASM-compatible randomness
```

### Rust Share Module Structure
```rust
// src/share.rs
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};
use flate2::Compression;
use flate2::write::DeflateEncoder;
use flate2::read::DeflateDecoder;

const EXPIRATION_SECS: u64 = 300; // 5 minutes

#[derive(Debug)]
pub struct SharePayload {
    pub data: String,  // Base64URL encoded encrypted payload
    pub key: String,   // Base64URL encoded AES key
}

pub fn create_share_payload(json: &str) -> Result<SharePayload, ShareError> {
    // 1. Compress JSON
    // 2. Prepend timestamp (8 bytes, big-endian Unix epoch)
    // 3. Generate random 256-bit key
    // 4. Generate random 12-byte nonce
    // 5. Encrypt with AES-256-GCM (nonce prepended to ciphertext)
    // 6. Base64URL encode both
}

pub fn decode_share_payload(data: &str, key: &str) -> Result<DecodeResult, ShareError> {
    // 1. Base64URL decode
    // 2. Extract nonce from ciphertext
    // 3. Decrypt with AES-256-GCM
    // 4. Extract and validate timestamp
    // 5. Decompress JSON
}
```

### URL Size Considerations
- GitHub Pages URL limit: ~8000 characters practical
- After compression + Base64: ~33% overhead (Base64) minus ~60-80% compression gain
- Practical limit: ~50KB uncompressed JSON (highly compressible)
- Rust module should return error if payload exceeds safe URL length (~6000 chars data)
- UI should warn when approaching limit before encoding

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Initial epic creation | Sarah (PO) |
| 2025-01-27 | 1.1 | Updated to Rust-first implementation per user request | Sarah (PO) |
| 2025-01-27 | 1.2 | Added optional passphrase feature, time-bounded encryption terminology, security tooltip | Sarah (PO) |
