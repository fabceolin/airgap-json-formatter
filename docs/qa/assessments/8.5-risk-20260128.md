# Risk Profile: Story 8.5 Toolbar Format Selector

Date: 2026-01-28
Reviewer: Quinn (Test Architect)

## Executive Summary

- Total Risks Identified: 5
- Critical Risks: 0
- High Risks: 0
- Medium Risks: 2
- Low Risks: 3
- Risk Score: 86/100 (Low Risk)

## Risk Matrix

| Risk ID   | Description                              | Probability | Impact     | Score | Priority |
|-----------|------------------------------------------|-------------|------------|-------|----------|
| TECH-001  | Format state sync race conditions        | Medium (2)  | Medium (2) | 4     | Medium   |
| TECH-002  | ComboBox styling inconsistency           | Low (1)     | Low (1)    | 1     | Minimal  |
| TECH-003  | Property binding complexity              | Medium (2)  | Medium (2) | 4     | Medium   |
| OPS-001   | Reset behavior edge cases                | Low (1)     | Medium (2) | 2     | Low      |
| BUS-001   | User confusion with override persistence | Low (1)     | Low (1)    | 1     | Minimal  |

## Detailed Risk Register

### TECH-001: Format State Sync Race Conditions

**Score: 4 (Medium)**
**Probability**: Medium - Multiple asynchronous state updates interact
**Impact**: Medium - Could cause wrong formatter to be used

**Description**: The story introduces `detectedFormat`, `manualFormatOverride`, and `effectiveFormat` properties that must stay synchronized. The detected format is updated via async `JsonBridge.detectFormat()` calls, while manual selection is synchronous. Race conditions could occur if:
- User manually selects format while auto-detection is in progress
- Input changes rapidly during manual selection
- Clear operation occurs mid-format-detection

**Affected Components**:
- `Toolbar.qml` (formatCombo, effectiveFormat property)
- `Main.qml` (detectedFormat binding, format routing)

**Mitigation**:
- Strategy: preventive
- Actions:
  - Use clear precedence: manual override always wins over detected
  - Reset override flag atomically when "Auto" is selected
  - Debounce format detection with existing `validationTimer`
- Testing Requirements:
  - Test rapid input changes while selector is open
  - Test manual selection during format detection
  - Test clear operation during format operations

**Residual Risk**: Low - QML property bindings handle most synchronization automatically

---

### TECH-002: ComboBox Styling Inconsistency

**Score: 1 (Minimal)**
**Probability**: Low - Clear pattern exists in codebase
**Impact**: Low - Visual-only issue

**Description**: The new format ComboBox must match existing `indentCombo` styling. Differences in background color, border radius, focus ring, or font size would create visual inconsistency.

**Affected Components**:
- `Toolbar.qml` (formatCombo styling)
- `Theme.qml` (styling constants)

**Mitigation**:
- Strategy: preventive
- Actions:
  - Copy exact styling from existing `indentCombo` component (lines 115-181 in Toolbar.qml)
  - Use Theme constants consistently
- Testing Requirements:
  - Visual comparison with existing ComboBox
  - Test in both light and dark themes

**Residual Risk**: Minimal - Clear pattern to follow

---

### TECH-003: Property Binding Complexity

**Score: 4 (Medium)**
**Probability**: Medium - Multiple computed properties interact
**Impact**: Medium - Could cause incorrect routing or display

**Description**: The story requires several computed properties:
- `effectiveFormat`: derived from `currentIndex` and `detectedFormat`
- `displayText`: changes based on mode ("JSON (auto)" vs "JSON")
- Format routing in `onFormatRequested` and `onMinifyRequested`

Circular binding dependencies or stale values could cause:
- Wrong format displayed
- Wrong formatter called
- Inconsistent state between toolbar display and actual operation

**Affected Components**:
- `Toolbar.qml` (formatCombo properties)
- `Main.qml` (format routing handlers)

**Mitigation**:
- Strategy: preventive
- Actions:
  - Use unidirectional data flow: `detectedFormat` from Main â†’ Toolbar
  - Compute `effectiveFormat` at point of use, not as stored state
  - Emit signal with computed format value, don't rely on property reads
- Testing Requirements:
  - Verify displayText updates correctly in all modes
  - Verify format signal contains correct value
  - Test state after rapid mode switches

**Residual Risk**: Low - QML binding engine is reliable when properly structured

---

### OPS-001: Reset Behavior Edge Cases

**Score: 2 (Low)**
**Probability**: Low - Clear reset trigger defined
**Impact**: Medium - Unexpected state after clear

**Description**: AC: 5 specifies "Format selection persists until input changes or manual clear". Edge cases:
- What happens on partial clear (backspace to empty)?
- Does paste into empty input reset format?
- Does loading from history reset format?

**Affected Components**:
- `Toolbar.qml` (format reset logic)
- `Main.qml` (clear handler, input change handler)

**Mitigation**:
- Strategy: corrective
- Actions:
  - Define reset trigger clearly: input.text becomes empty OR clear button pressed
  - Document expected behavior in code comments
- Testing Requirements:
  - Test backspace to empty
  - Test paste after clear
  - Test history load with different format

**Residual Risk**: Low - Behavior can be clearly defined

---

### BUS-001: User Confusion with Override Persistence

**Score: 1 (Minimal)**
**Probability**: Low - Tooltip explains behavior
**Impact**: Low - User confusion, not data loss

**Description**: Users might not understand:
- Why format stays "XML" after pasting JSON content
- When auto-detection resumes
- That override persists until input clears

**Affected Components**:
- UI/UX behavior
- Tooltip text

**Mitigation**:
- Strategy: detective
- Actions:
  - Clear tooltip text (AC: 6): "Format is auto-detected. Select manually to override."
  - Consider visual indicator when in override mode (future enhancement)
- Testing Requirements:
  - Verify tooltip displays correctly
  - Verify tooltip text is understandable

**Residual Risk**: Minimal - Tooltip addresses concern

---

## Risk Distribution

### By Category
- Technical: 3 risks (0 critical)
- Business: 1 risk (0 critical)
- Operational: 1 risk (0 critical)
- Security: 0 risks
- Performance: 0 risks
- Data: 0 risks

### By Component
- Toolbar.qml: 4 risks
- Main.qml: 3 risks (overlap with Toolbar)
- Theme.qml: 1 risk

## Risk-Based Testing Strategy

### Priority 1: State Synchronization Tests
- Test manual selection during auto-detection
- Test rapid input changes
- Test clear during format operation
- Test format signal emission timing

### Priority 2: Visual/Styling Tests
- Compare formatCombo with indentCombo visually
- Test in light and dark themes
- Verify focus ring appearance
- Test responsive/compact mode styling

### Priority 3: Edge Case Tests
- Test backspace to empty input
- Test paste into empty input
- Test history load with different formats
- Test keyboard navigation (AC: 7)

## Risk Acceptance Criteria

### Must Fix Before Production
- None (no critical or high risks)

### Can Deploy with Mitigation
- TECH-001, TECH-003: Implement clear state precedence rules
- OPS-001: Document reset behavior

### Accepted Risks
- TECH-002: Visual inconsistency risk accepted (clear pattern exists)
- BUS-001: User confusion risk accepted (tooltip mitigates)

## Monitoring Requirements

Post-deployment monitoring:
- None required (UI-only changes, no backend/performance impact)

## Gate YAML Block

```yaml
# risk_summary (paste into gate file):
risk_summary:
  totals:
    critical: 0
    high: 0
    medium: 2
    low: 3
  highest:
    id: TECH-001
    score: 4
    title: "Format state sync race conditions"
  recommendations:
    must_fix: []
    monitor: []
```

## Risk Review Triggers

Review and update risk profile when:
- Additional format types added (Markdown, YAML)
- Format detection logic changes
- Toolbar layout significantly modified
