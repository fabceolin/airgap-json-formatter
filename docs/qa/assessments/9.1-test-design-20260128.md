# Test Design: Story 9.1 â€” Rust Share Encoding Module

Date: 2026-01-28
Designer: Quinn (Test Architect)

## Test Strategy Overview

- Total test scenarios: 28
- Unit tests: 20 (71%)
- Integration tests: 5 (18%)
- E2E tests: 3 (11%)
- Priority distribution: P0: 10, P1: 11, P2: 7

## Test Scenarios by Acceptance Criteria

### AC1: `create_share_payload` function signature and module structure

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-001 | Unit | P1 | Call `create_share_payload` with valid JSON and `None` passphrase | Returns `Ok(SharePayload)` with `data` and `key: Some(...)` | Pure function contract |
| 9.1-UNIT-002 | Unit | P1 | Call `create_share_payload` with valid JSON and `Some("pass")` | Returns `Ok(SharePayload)` with `data` and `key: None` | Pure function contract |

### AC2: `SharePayload` struct fields

Covered by AC1 tests (return type assertions).

### AC3: DEFLATE compression before encryption

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-003 | Unit | P1 | Compress typical JSON (~1KB) and verify output is smaller | Compressed size < original size | Pure algorithm |
| 9.1-UNIT-004 | Unit | P2 | Compress already-small JSON (< 20 bytes) | Succeeds (may not reduce size) | Edge case |
| 9.1-UNIT-005 | Unit | P2 | Compress JSON with repeated keys (high redundancy) | Compression ratio > 50% | Algorithm effectiveness |

### AC4: Version byte prepended

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-006 | Unit | P0 | Random key mode payload starts with `0x01` after decryption | First byte == `0x01` | Security-critical â€” wrong version breaks decoding |
| 9.1-UNIT-007 | Unit | P0 | Passphrase mode payload starts with `0x02` after decryption | First byte == `0x02` | Security-critical |

### AC5: Unix timestamp (8 bytes big-endian) after version byte

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-008 | Unit | P1 | Extract timestamp from encrypted payload, verify it's within Â±2s of `now` | Timestamp is recent and valid u64 | Correctness of time-bounding |
| 9.1-UNIT-009 | Unit | P2 | Verify timestamp bytes are big-endian encoded | Bytes decode correctly as big-endian u64 | Binary format correctness |

### AC6: Random key mode â€” 256-bit AES key generation

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-010 | Unit | P0 | `generate_random_key()` returns 32-byte array | Key length == 32 | Crypto correctness |
| 9.1-UNIT-011 | Unit | P1 | Call `generate_random_key()` twice, keys differ | key1 != key2 | Randomness verification |
| 9.1-UNIT-012 | Unit | P0 | Random key mode returns key in `SharePayload.key` | `key` field is `Some(...)` with valid Base64URL string | Contract |

### AC7: Passphrase mode â€” PBKDF2-SHA256, 100K iterations, 16-byte salt

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-013 | Unit | P0 | Same passphrase + same salt = same derived key | Keys are identical | Deterministic derivation |
| 9.1-UNIT-014 | Unit | P0 | Different passphrase + same salt = different key | Keys differ | Security correctness |
| 9.1-UNIT-015 | Unit | P1 | Same passphrase + different salt = different key | Keys differ | Salt effectiveness |
| 9.1-UNIT-016 | Unit | P1 | Salt is exactly 16 bytes in output payload | Salt extracted from payload is 16 bytes | Spec compliance |

### AC8: AES-256-GCM encryption with random 12-byte nonce

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-017 | Unit | P0 | Encrypt then decrypt with same key recovers plaintext | Decrypted data == original | Crypto round-trip |
| 9.1-UNIT-018 | Unit | P0 | Tamper with ciphertext, decrypt fails | Returns error (GCM auth tag verification) | Integrity guarantee |
| 9.1-UNIT-019 | Unit | P1 | Encrypt same data twice, ciphertexts differ | ct1 != ct2 | Nonce uniqueness |

### AC9: Base64URL encoding (URL-safe, no padding)

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-UNIT-020 | Unit | P1 | Encoded output contains no `+`, `/`, or `=` characters | Regex `[+/=]` finds no matches | URL safety |

### AC10: PayloadTooLarge error if encoded data > 6000 chars

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-INT-001 | Integration | P1 | Pass JSON that compresses+encrypts+encodes to > 6000 chars | Returns `ShareError::PayloadTooLarge` | Multi-component size check |
| 9.1-INT-002 | Integration | P2 | Pass JSON that encodes to exactly 6000 chars | Returns `Ok(...)` (boundary) | Boundary condition |

### AC11: WASM binding `createSharePayload`

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-INT-003 | Integration | P0 | Call WASM binding with empty passphrase (random key mode) | JSON response: `{"success": true, "data": "...", "key": "...", "mode": "quick"}` | WASM boundary |
| 9.1-INT-004 | Integration | P0 | Call WASM binding with passphrase | JSON response: `{"success": true, "data": "...", "mode": "protected"}` | WASM boundary |
| 9.1-INT-005 | Integration | P1 | Call WASM binding with empty JSON string | JSON response: `{"success": false, "error": "..."}` | Error propagation across WASM |

### AC12: Unit tests â€” round-trip, derivation consistency, error handling

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-E2E-001 | E2E | P0 | Full round-trip: create payload (random key) â†’ decode payload â†’ original JSON | Recovered JSON matches input | Critical user journey |
| 9.1-E2E-002 | E2E | P0 | Full round-trip: create payload (passphrase) â†’ decode with same passphrase â†’ original JSON | Recovered JSON matches input | Critical user journey |
| 9.1-E2E-003 | E2E | P1 | Create payload (passphrase) â†’ decode with wrong passphrase â†’ error | Decryption fails | Security validation |

### AC13: WASM size increase < 150KB gzipped

| ID | Level | Priority | Test | Expected Result | Justification |
|----|-------|----------|------|-----------------|---------------|
| 9.1-INT-006 | Integration | P2 | Measure WASM binary size before and after adding share module | Delta < 150KB gzipped | Build artifact validation |

## Risk Coverage

| Risk ID | Test IDs | Coverage |
|---------|----------|----------|
| SEC-001 (Incorrect crypto) | 9.1-UNIT-017, 018, 019, E2E-001, E2E-002 | Full |
| TECH-001 (WASM compat) | 9.1-INT-003, 004, 005 | Full |
| PERF-001 (PBKDF2 blocking) | Not covered by functional tests â€” needs benchmark (see notes) | Gap |
| SEC-003 (Timestamp replay) | 9.1-UNIT-008 | Partial (encoding only; decoding validates in Story 9.2) |
| OPS-001 (WASM size) | 9.1-INT-006 | Full |
| SEC-004 (Key in JS memory) | Accepted risk â€” not testable at Rust level | N/A |
| SEC-002 (PBKDF2 flaw) | 9.1-UNIT-013, 014, 015 | Full |
| TECH-002 (Compression oracle) | Accepted risk â€” mitigated by design (no attacker-controlled prefix) | N/A |
| DATA-001 (6000 char limit) | 9.1-INT-001, 002 | Full |

## Test Data Requirements

| Data | Description | Usage |
|------|-------------|-------|
| Small JSON | `{"key": "value"}` (~16 bytes) | Minimum viable payload |
| Typical JSON | ~1KB API response with nested objects | Standard round-trip |
| Large JSON | ~50KB+ payload to trigger PayloadTooLarge | Boundary/error testing |
| Unicode JSON | `{"emoji": "ðŸŽ‰", "cjk": "æ—¥æœ¬èªž"}` | Encoding integrity |
| Empty string | `""` | EmptyInput error |
| Valid passphrases | `"test123"`, `"complex P@ss!"`, `""` (empty = random key) | Both modes |

## Environment Requirements

- Rust toolchain with `wasm32-unknown-unknown` target
- `wasm-bindgen-test` for WASM integration tests
- Browser or `wasm-pack test --node` for WASM execution
- Baseline WASM binary size snapshot for AC13 delta check

## Recommended Execution Order

1. P0 Unit tests â€” crypto correctness (UNIT-006, 007, 010, 012, 013, 014, 017, 018)
2. P0 Integration tests â€” WASM bindings (INT-003, 004)
3. P0 E2E tests â€” full round-trip (E2E-001, 002)
4. P1 Unit tests â€” randomness, encoding, timestamps
5. P1 Integration/E2E â€” error propagation, wrong passphrase
6. P2 tests â€” boundaries, size checks, edge cases

## Coverage Gaps & Notes

1. **PERF-001 not covered**: PBKDF2 latency benchmark is recommended but not included as a functional test. Recommend adding a dedicated benchmark test with a <500ms threshold in WASM.
2. **Round-trip tests require Story 9.2**: Full E2E round-trip (encodeâ†’decode) depends on the decoding module from Story 9.2. For Story 9.1 alone, test encoding output format correctness (version byte, timestamp, structure) and verify decryptability with known keys.

## Gate YAML Block

```yaml
test_design:
  scenarios_total: 28
  by_level:
    unit: 20
    integration: 6
    e2e: 3
  by_priority:
    p0: 10
    p1: 11
    p2: 7
  coverage_gaps:
    - "PERF-001: PBKDF2 WASM latency benchmark not included as functional test"
    - "E2E round-trip depends on Story 9.2 decoding module"
```

---

Test design matrix: docs/qa/assessments/9.1-test-design-20260128.md
P0 tests identified: 10
