//! JSON syntax highlighter using syntect
//!
//! Provides syntax highlighting for JSON using a minimal pre-compiled syntax set.
//! Only includes JSON syntax to minimize WASM binary size.
//! Uses the base16-ocean.dark theme for VS Code-like appearance.

use once_cell::sync::Lazy;
use syntect::highlighting::Theme;
use syntect::html::highlighted_html_for_string;
use syntect::parsing::SyntaxSet;

// Pre-compiled JSON-only syntax set and theme (generated by build.rs)
static JSON_SYNTAX: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/json_syntax.bin"));
static THEME_DATA: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/theme.bin"));

// Load minimal syntax set and theme once (lazy static)
static SYNTAX_SET: Lazy<SyntaxSet> = Lazy::new(|| {
    syntect::dumps::from_binary(JSON_SYNTAX)
});

static THEME: Lazy<Theme> = Lazy::new(|| {
    syntect::dumps::from_binary(THEME_DATA)
});

/// Highlights JSON string and returns HTML with inline styles.
///
/// # Arguments
/// * `input` - The JSON string to highlight
///
/// # Returns
/// * HTML string with inline styles for syntax highlighting
/// * Empty string if input is empty
/// * Escaped plain text if highlighting fails
pub fn highlight_json(input: &str) -> String {
    if input.is_empty() {
        return String::new();
    }

    let syntax = SYNTAX_SET
        .find_syntax_by_extension("json")
        .unwrap_or_else(|| SYNTAX_SET.find_syntax_plain_text());

    match highlighted_html_for_string(input, &SYNTAX_SET, syntax, &THEME) {
        Ok(html) => html,
        Err(_) => {
            // Fallback: return escaped plain text
            html_escape(input)
        }
    }
}

/// Escapes HTML special characters in a string.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_highlight_empty_input() {
        let result = highlight_json("");
        assert!(result.is_empty());
    }

    #[test]
    fn test_highlight_basic_json() {
        let input = r#"{"key": "value", "num": 42}"#;
        let result = highlight_json(input);
        // Should contain HTML spans for styling
        assert!(result.contains("<span"));
        assert!(result.contains("key"));
        assert!(result.contains("value"));
        assert!(result.contains("42"));
    }

    #[test]
    fn test_highlight_all_json_types() {
        let input = r#"{
  "string": "hello",
  "number": 123,
  "float": 3.14,
  "boolean_true": true,
  "boolean_false": false,
  "null_value": null,
  "array": [1, 2, 3],
  "object": {"nested": "value"}
}"#;
        let result = highlight_json(input);
        assert!(result.contains("<span"));
        assert!(result.contains("string"));
        assert!(result.contains("hello"));
        assert!(result.contains("123"));
        assert!(result.contains("true"));
        assert!(result.contains("false"));
        assert!(result.contains("null"));
    }

    #[test]
    fn test_html_escape() {
        let input = "<script>&test</script>";
        let result = html_escape(input);
        assert_eq!(result, "&lt;script&gt;&amp;test&lt;/script&gt;");
    }
}
